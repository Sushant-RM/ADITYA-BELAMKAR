<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm and Data Structure Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #4CAF50;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
        section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Algorithm and Data Structure Concepts</h1>

    <section>
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> Repeated processes, e.g., population growth, weather cycles.</li>
            <li><strong>Recursion:</strong> Self-similar problems, e.g., fractals, Fibonacci sequences.</li>
            <li><strong>Backtracking:</strong> Exploring multiple solutions, e.g., maze solving, ant foraging.</li>
        </ul>
    </section>

    <section>
        <h2>2. Space and Time Efficiency</h2>
        <p><strong>Definition:</strong> Space refers to memory usage, and time refers to execution speed.</p>
        <p><strong>Importance:</strong> Crucial for optimizing performance and handling large-scale problems.</p>
        <h3>Orders of Growth:</h3>
        <ul>
            <li><strong>O(1):</strong> Constant time, e.g., array access.</li>
            <li><strong>O(log n):</strong> Logarithmic time, e.g., binary search.</li>
            <li><strong>O(n):</strong> Linear time, e.g., linear search.</li>
            <li><strong>O(n²):</strong> Quadratic time, e.g., bubble sort.</li>
            <li><strong>O(2ⁿ):</strong> Exponential time, e.g., recursive backtracking.</li>
        </ul>
    </section>

    <section>
        <h2>3. Design Principles</h2>
        <ul>
            <li><strong>Abstraction:</strong> Focus on essentials, hide details.</li>
            <li><strong>Divide and Conquer:</strong> Break down into subproblems, e.g., merge sort.</li>
            <li><strong>Dynamic Programming:</strong> Solve overlapping subproblems, e.g., Fibonacci memoization.</li>
            <li><strong>Greedy Algorithms:</strong> Locally optimal choices, e.g., Kruskal's MST algorithm.</li>
        </ul>
    </section>

    <section>
        <h2>4. Hierarchical Data and Tree Structures</h2>
        <ul>
            <li><strong>Tree:</strong> Parent-child hierarchy, e.g., file systems.</li>
            <li><strong>Binary Search Tree:</strong> Optimized for search, insert, delete.</li>
            <li><strong>AVL Tree:</strong> Self-balancing BST with O(log n) operations.</li>
            <li><strong>2-3 Tree:</strong> Multi-way balanced tree for databases.</li>
            <li><strong>Red-Black Tree:</strong> Balanced search trees for efficient updates.</li>
            <li><strong>Heap:</strong> Priority queue implementation.</li>
            <li><strong>Trie:</strong> Prefix tree for dictionary operations.</li>
        </ul>
    </section>

    <section>
        <h2>5. Array Query Algorithms</h2>
        <p><strong>Need:</strong> Efficient range queries and updates.</p>
        <p><strong>Applications:</strong> Competitive programming, data analytics.</p>
    </section>

    <section>
        <h2>6. Trees vs. Graphs</h2>
        <ul>
            <li><strong>Trees:</strong> Hierarchical structures, e.g., file systems.</li>
            <li><strong>Graphs:</strong> More general, cyclic or disconnected, e.g., social networks.</li>
        </ul>
    </section>

    <section>
        <h2>7. Sorting and Searching Algorithms</h2>
        <ul>
            <li><strong>Sorting:</strong> Organizing data, e.g., quick sort, merge sort.</li>
            <li><strong>Searching:</strong> Finding data, e.g., binary search, linear search.</li>
        </ul>
    </section>

    <section>
        <h2>8. Graph Algorithms</h2>
        <ul>
            <li><strong>Spanning Trees:</strong> Minimum edge subgraphs, e.g., Kruskal's algorithm.</li>
            <li><strong>Shortest Paths:</strong> Find optimal paths, e.g., Dijkstra's algorithm.</li>
        </ul>
    </section>

    <section>
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Divide and Conquer:</strong> Merge sort, quick sort.</li>
            <li><strong>Dynamic Programming:</strong> Knapsack problem, Floyd-Warshall.</li>
            <li><strong>Greedy Algorithms:</strong> Huffman coding.</li>
            <li><strong>Backtracking:</strong> Sudoku solving.</li>
            <li><strong>Branch and Bound:</strong> Optimization problems.</li>
        </ul>
    </section>
</body>
</html>
