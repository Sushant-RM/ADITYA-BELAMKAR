<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm and Data Structure Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #4CAF50;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
        section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Algorithm and Data Structure Concepts</h1>

    <section>
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> Repeated processes, e.g., population growth, weather cycles.</li>
            <li><strong>Recursion:</strong> Self-similar problems, e.g., fractals,Towers of Hanoi, Fibonacci sequences.</li>
            <li><strong>Backtracking:</strong> Exploring multiple solutions, e.g., N-Queens problem, maze solving, ant foraging.</li>
        </ul>
    </section>

    <section>
        <h2>2. Space and Time Efficiency</h2>
        <p><strong>Definition:</strong> Space refers to memory usage, and time refers to execution speed.</p>
        <p><strong>Importance:</strong> Crucial for optimizing performance and handling large-scale problems.</p>
        <h3>Orders of Growth:</h3>
        <ul>
            <li><strong>O(1):</strong> Constant time, e.g., array access.</li>
            <li><strong>O(log n):</strong> Logarithmic time, e.g., binary search.</li>
            <li><strong>O(n):</strong> Linear time, e.g., linear search.</li>
            <li><strong>O(n²):</strong> Quadratic time, e.g., bubble sort.</li>
            <li><strong>O(2ⁿ):</strong> Exponential time, e.g., recursive backtracking.</li>
        </ul>
    </section>

    <section>
        <h2>3. Design Principles</h2>
        <ul>
            <li><strong>Abstraction:</strong> Focus on essentials, hide details.</li>
            <li><strong>Divide and Conquer:</strong> Break down problems into subproblems, e.g., merge sort.</li>
            <li><strong>Dynamic Programming:</strong> Solve overlapping subproblems, e.g., Fibonacci memoization,Longest common subsequences.</li>
            <li><strong>Greedy Algorithms:</strong> Locally optimal choices for global solutions, e.g., Kruskal's algorithm for minimum spanning tree(MST).</li>
        </ul>
    </section>

    <section>
        <h2>4. Hierarchical Data and Tree Structures</h2>
        <ul>
            <li><strong> Binary Tree:</strong> Parent-child hierarchy, e.g., file systems.</li>
            <li><strong>Binary Search Tree:</strong> Optimized for search, insert, delete.</li>
            <li><strong>AVL Tree:</strong> Self-balancing BST with O(log n) operations.</li>
            <li><strong>2-3 Tree:</strong> Multi-way balanced tree for databases.</li>
            <li><strong>Red-Black Tree:</strong> Balanced search trees for efficient updates.</li>
            <li><strong>Heap:</strong> Priority queue implementation.</li>
            <li><strong>Trie:</strong> Prefix tree for dictionary operations.</li>
        </ul>
    </section>

    <section>
        <h2>5. Array Query Algorithms</h2>
        <p><strong>Need:</strong> Efficient range queries and updates.</p>
        <p><strong>Applications:</strong> Competitive programming, data analytics.</p>
    </section>

    <section>
       <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Difference Between Trees and Graphs</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 18px;
            text-align: left;
        }
        th, td {
            padding: 12px;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <h1>Difference Between Trees and Graphs</h1>
    <table>
        <thead>
            <tr>
                <th>TREES</th>
                <th>GRAPHS</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>A special type of graph with no cycles, used for hierarchical data (e.g., file systems).</td>
                <td>Can represent complex relationships with or without cycles (e.g., social networks).</td>
            </tr>
            <tr>
                <td>Traversals: Follows a hierarchical path.</td>
                <td>Traversals: Explores all possible paths, can revisit nodes.</td>
            </tr>
            <tr>
                <td>Types of Traversals: Inorder, preorder, postorder.</td>
                <td>Types of Traversals: BFS, DFS.</td>
            </tr>
            <tr>
                <td>Applications: File systems, expression trees, binary search trees.</td>
                <td>Applications: Social networks, network routing, scheduling problems.</td>
            </tr>
        </tbody>
    </table>
</body>
</html>
    </section>

    <section>
        <h2>7. Sorting and Searching Algorithms</h2>
        <ul>
            <li><strong>Sorting:</strong> Organizing data, e.g., quick sort, merge sort.</li>
            <li><strong>Searching:</strong> Finding data, e.g., binary search, linear search.</li>
        </ul>
    </section>

    <section>
        <h2>8. Graph Algorithms</h2>
        <ul>
            <li><strong>Spanning Trees:</strong> Minimum edge subgraphs, e.g., Kruskal's algorithm.</li>
            <li><strong>Shortest Paths:</strong> Find optimal paths, e.g., Dijkstra's algorithm.</li>
        </ul>
    </section>

    <section>
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Divide and Conquer:</strong> Merge sort, quick sort.</li>
            <li><strong>Dynamic Programming:</strong> Knapsack problem, Floyd-Warshall.</li>
            <li><strong>Greedy Algorithms:</strong> Huffman coding.</li>
            <li><strong>Backtracking:</strong> Sudoku solving.</li>
            <li><strong>Branch and Bound:</strong> Optimization problems.</li>
        </ul>
    </section>
</body>
</html>
